# 05. 함수

## 1) 함수

함수는 특정 작업을 수행하기 위한 코드들의 모임입니다. 마치 요리 레시피나 자판기와 같다고 생각할 수 있습니다. 요리 레시피는 특정 요리를 만들기 위한 순서와 방법을 담고 있고, 자판기는 버튼을 누르면 정해진 음료를 내어주는 것처럼, 함수도 우리가 원하는 작업을 미리 정해두고 필요할 때마다 그 이름을 불러서 실행할 수 있습니다.

함수를 사용하는 가장 큰 이유는 다음과 같습니다:

*   **코드 재사용**: 똑같은 작업을 여러 번 반복해서 작성할 필요 없이, 한 번 함수로 만들어두면 언제든지 다시 사용할 수 있습니다.
*   **코드 정리**: 복잡한 작업을 여러 개의 작은 함수로 나누어 작성하면, 코드를 이해하기 쉽고 관리하기 편리해집니다.
*   **오류 줄이기**: 한 번 잘 만들어진 함수는 여러 곳에서 사용되므로, 오류가 발생할 가능성이 줄어듭니다.

```javascript
// sayHello라는 이름의 함수에 '안녕하세요!'를 콘솔에 출력하는 동작을 담아둠
function sayHello() {
  console.log('안녕하세요!');
}

sayHello(); // 함수 이름을 불러 동작을 실행 --> '안녕하세요!' 출력
sayHello(); // 또 다시 함수를 호출하여 같은 동작을 반복
```

> [!TIP]
> 함수를 만들 때는 `function` 키워드, 함수 이름, 소괄호 `()`, 그리고 중괄호 `{}`를 사용합니다. 중괄호 `{}` 안에는 함수가 실행할 코드들을 작성합니다.

## 2) 매개변수(parameter)와 인자(argument)

함수는 외부로부터 값을 받아서 작업을 수행할 수 있습니다. 이때 함수가 외부로부터 받는 값을 '매개변수'와 '인자'라고 부릅니다. 이 둘은 비슷해 보이지만 역할이 다릅니다.

*   **매개변수 (Parameter)**: 함수를 정의할 때, 함수가 어떤 종류의 값을 받을 것인지 미리 정해놓는 '빈 상자' 또는 '빈칸'과 같습니다. 함수 이름 뒤 괄호 `()` 안에 작성합니다.
*   **인자 (Argument)**: 함수를 호출할 때, 매개변수에 실제로 넣어주는 '구체적인 값'입니다. 함수를 실행할 때 괄호 `()` 안에 작성합니다.

예를 들어, '이름을 받아서 인사하는 함수'를 만든다고 생각해봅시다. 여기서 '이름'은 매개변수가 되고, 실제로 '철수', '영희'와 같은 이름은 인자가 됩니다.

```javascript
function greet(name) {          // 여기서 name은 매개변수입니다. 함수가 받을 값을 미리 정해놓은 것이죠.
  console.log('안녕, ' + name + '!'); // name에 전달된 값이 사용됩니다.
}

greet('철수');                  // 함수를 호출하면서 '철수'라는 인자를 전달합니다.
                               // 이 '철수'라는 값이 위 함수의 name 매개변수로 들어갑니다.
greet('영희');                  // '영희'라는 인자를 전달합니다.

function add(num1, num2) {      // num1과 num2는 매개변수입니다.
  return num1 + num2;
}

let result = add(5, 3);         // 5와 3은 인자입니다. num1에 5, num2에 3이 전달됩니다.
console.log(result);            // 출력: 8
```

> [!NOTE]
> 매개변수는 함수 내부에서만 유효한 변수입니다. 함수가 호출될 때 인자로 전달된 값으로 초기화됩니다. 인자의 개수와 매개변수의 개수가 일치하지 않아도 오류가 발생하지는 않지만, 의도한 대로 동작하지 않을 수 있으므로 주의해야 합니다.

---

## 3) ES6+ 화살표 함수(Arrow Function)

ES6(ECMAScript 2015)부터는 함수를 더 간결하게 작성할 수 있는 '화살표 함수' 문법이 도입되었습니다. 특히 짧은 함수를 만들 때 유용하며, 코드를 더 깔끔하게 보이게 합니다.

### 일반 함수와 화살표 함수의 비교

```javascript
// 일반 함수 (function 키워드 사용)
function add(a, b) {
  return a + b;
}
console.log(add(1, 2)); // 출력: 3

// 화살표 함수 기본 형태 (const 키워드와 => 사용)
const addArrow = (a, b) => {
  return a + b;
};
console.log(addArrow(1, 2)); // 출력: 3
```

### 화살표 함수의 간결한 사용법

*   **중괄호 `{}`와 `return` 생략**: 함수 본문이 `return` 문 하나로 이루어져 있다면, 중괄호와 `return` 키워드를 생략하고 한 줄로 작성할 수 있습니다. 이 경우 `=>` 뒤의 표현식의 결과가 자동으로 반환됩니다.

    ```javascript
    const multiply = (a, b) => a * b; // a * b의 결과가 자동으로 반환됩니다.
    console.log(multiply(3, 4)); // 출력: 12
    ```

*   **매개변수가 하나일 때 괄호 `()` 생략**: 매개변수가 하나뿐이라면, 매개변수를 감싸는 괄호를 생략할 수 있습니다.

    ```javascript
    const greet = name => `안녕, ${name}!`; // 매개변수가 name 하나이므로 괄호 생략 가능
    console.log(greet('민수')); // 출력: 안녕, 민수!
    ```

*   **매개변수가 없을 때 괄호 `()` 사용**: 매개변수가 없다면, 빈 괄호를 반드시 사용해야 합니다.

    ```javascript
    const sayHello = () => console.log('Hello!');
    sayHello(); // 출력: Hello!
    ```

> [!TIP]
> 화살표 함수는 코드를 간결하게 만들어주지만, 일반 함수와는 몇 가지 미묘한 차이점이 있습니다. 특히 `this` 키워드의 동작 방식이 다르지만, 이 부분은 나중에 더 깊이 있는 학습에서 다루겠습니다. 지금은 '함수를 더 짧게 쓸 수 있는 새로운 방법' 정도로 이해하면 충분합니다.

## 4) 기본 매개변수(Default Parameters)

함수를 호출할 때, 모든 매개변수에 값을 전달하지 않아도 되는 경우가 있습니다. 이럴 때 특정 매개변수에 미리 '기본값'을 설정해두면, 해당 매개변수에 값이 전달되지 않았을 때 자동으로 기본값이 사용됩니다.

```javascript
function makeTea(type = '홍차') { // type 매개변수에 기본값으로 '홍차'를 설정했습니다.
  console.log(type + '가 준비되었습니다.');
}

makeTea();        // 인자를 넘기지 않았으므로, type은 기본값인 '홍차'가 됩니다. 출력: '홍차가 준비되었습니다.'
makeTea('녹차');  // '녹차'라는 인자를 넘겼으므로, type은 '녹차'가 됩니다. 출력: '녹차가 준비되었습니다.'
makeTea('아메리카노'); // 출력: '아메리카노가 준비되었습니다.'
```

> [!NOTE]
> 기본 매개변수는 함수를 더 유연하게 만들고, 함수 호출 시 인자를 빠뜨렸을 때 발생할 수 있는 오류를 줄여줍니다. 특히 선택적인 인자가 많은 함수에서 유용하게 사용됩니다.

---

## 5) 나머지 매개변수(Rest Parameters)

함수를 만들 때, 몇 개의 인자가 전달될지 미리 알 수 없는 경우가 있습니다. 예를 들어, '모든 숫자를 더하는 함수'를 만들고 싶은데, 어떤 때는 2개의 숫자를 더하고, 어떤 때는 10개의 숫자를 더해야 할 수도 있습니다. 이럴 때 '나머지 매개변수'를 사용하면, 전달된 모든 인자들을 하나의 '배열'로 묶어서 받을 수 있습니다.

나머지 매개변수는 매개변수 이름 앞에 점 세 개(`...`)를 붙여서 사용합니다.

```javascript
function sumAll(...numbers) {      // numbers는 이제 전달된 모든 인자들을 담은 배열이 됩니다.
  let total = 0;
  for (let num of numbers) { // 배열의 각 요소를 반복하며 더합니다.
    total += num;
  }
  return total;
}

console.log(sumAll(1, 2, 3));       // 출력: 6 (1 + 2 + 3)
console.log(sumAll(5, 10, 15, 20)); // 출력: 50 (5 + 10 + 15 + 20)
console.log(sumAll());              // 출력: 0 (인자가 없으면 빈 배열이 됩니다.)
```

나머지 매개변수는 다른 일반 매개변수와 함께 사용할 수도 있습니다. 이 경우, 나머지 매개변수는 항상 마지막에 위치해야 합니다. 즉, 함수에 전달된 인자들 중에서 앞의 인자들은 순서대로 일반 매개변수에 할당되고, 그 나머지 인자들이 모두 나머지 매개변수에 배열로 담기게 됩니다.

```javascript
// name과 age는 일반 매개변수, ...hobbies는 나머지 매개변수입니다.
function introduce(name, age, ...hobbies) {
  console.log(`안녕하세요, 제 이름은 ${name}이고, 나이는 ${age}살입니다.`);
  
  if (hobbies.length > 0) {
    // hobbies 배열에 요소가 있을 때만 취미를 출력합니다.
    console.log(`제 취미는 ${hobbies.join(', ')}입니다.`);
  } else {
    console.log('아직 취미가 없습니다.');
  }
}

introduce('철수', 20, '축구', '게임', '독서');
// 출력:
// 안녕하세요, 제 이름은 철수이고, 나이는 20살입니다.
// 제 취미는 축구, 게임, 독서입니다.

introduce('영희', 22, '요리');
// 출력:
// 안녕하세요, 제 이름은 영희이고, 나이는 22살입니다.
// 제 취미는 요리입니다.

introduce('민수', 25);
// 출력:
// 안녕하세요, 제 이름은 민수이고, 나이는 25살입니다.
// 아직 취미가 없습니다.
```

> [!NOTE]
> 나머지 매개변수는 반드시 함수 정의의 마지막 매개변수로 선언해야 합니다. 중간이나 처음에 위치할 수 없습니다.
> `function wrongExample(...rest, a, b) { ... }` // (X) 잘못된 문법입니다!

> [!TIP]
> 나머지 매개변수는 함수에 전달될 인자의 개수가 가변적일 때 매우 유용합니다. `...` 문법은 배열을 다루는 데 있어 매우 강력한 기능이므로, 나중에 배열을 배울 때 다시 만나게 될 것입니다.

## 6) 콜백 함수(Callback Function)

**콜백 함수**는 다른 함수의 '인자'로 전달되는 함수를 말합니다. 그리고 이 콜백 함수는 전달받은 함수(고차 함수) 내부에서 특정 시점에 호출됩니다. 마치 여러분이 친구에게 '내가 숙제를 다 하면, 네가 이어서 게임을 시작해줘'라고 부탁하는 것과 같습니다. 여기서 '네가 이어서 게임을 시작하는 것'이 콜백 함수가 됩니다.

콜백 함수는 주로 다음과 같은 상황에서 사용됩니다:

*   **비동기 작업 처리**: 웹 페이지에서 서버로부터 데이터를 가져오거나, 파일을 읽는 등 시간이 오래 걸리는 작업이 완료된 후에 특정 동작을 수행해야 할 때 사용합니다. (예: `setTimeout`, `fetch`)
*   **이벤트 처리**: 사용자가 버튼을 클릭하거나, 키보드를 누르는 등의 '이벤트'가 발생했을 때 실행될 함수를 지정할 때 사용합니다. (예: `addEventListener`)
*   **배열 메서드**: `map()`, `filter()`, `forEach()`와 같은 배열의 내장 메서드들은 각 요소에 대해 특정 작업을 수행하기 위해 콜백 함수를 인자로 받습니다.

### 콜백 함수 사용 예시

```javascript
// 1. 다른 함수에 인자로 전달되는 콜백 함수
function greet(name, callback) {
  console.log('안녕하세요, ' + name + '님!');
  callback(); // 전달받은 콜백 함수를 호출합니다.
}

function sayGoodbye() {
  console.log('다음에 또 만나요!');
}

greet('철수', sayGoodbye); // greet 함수에 sayGoodbye 함수를 콜백으로 전달합니다.
// 출력:
// 안녕하세요, 철수님!
// 다음에 또 만나요!

// 함수를 직접 정의하여 콜백으로 전달할 수도 있습니다.
greet('영희', function() {
  console.log('즐거운 하루 되세요!');
});
// 출력:
// 안녕하세요, 영희님!
// 즐거운 하루 되세요!

// 2. 비동기 작업에서의 콜백 (setTimeout 예시)
function delayedMessage(message, delayTime, callback) {
  setTimeout(function() { // delayTime 후에 이 함수가 실행됩니다.
    console.log(message);
    callback(); // 메시지 출력 후 콜백 함수 호출
  }, delayTime);
}

console.log('시작!');
delayedMessage('3초 후에 나타나는 메시지', 3000, function() {
  console.log('콜백 함수가 실행되었습니다.');
});
console.log('끝!');
// 출력 순서:
// 시작!
// 끝!
// (3초 후)
// 3초 후에 나타나는 메시지
// 콜백 함수가 실행되었습니다.

// 3. 배열 메서드에서의 콜백 (forEach 예시)
const numbers = [1, 2, 3];

numbers.forEach(function(number) { // forEach는 배열의 각 요소에 대해 콜백 함수를 실행합니다.
  console.log(number * 2);
});
// 출력:
// 2
// 4
// 6
```

> [!NOTE]
> 콜백 함수는 JavaScript의 비동기 처리와 이벤트 기반 프로그래밍에서 매우 중요한 개념입니다. 함수를 값처럼 다룰 수 있는 JavaScript의 특징 덕분에 가능합니다. 하지만 여러 콜백 함수가 중첩될 경우 '콜백 헬(Callback Hell)'이라는 문제가 발생할 수 있으며, 이는 나중에 Promise와 async/await를 통해 해결하는 방법을 배우게 될 것입니다.

## 7) 고차 함수(Higher-Order Function)

고차 함수(Higher-Order Function)는 이름 그대로 '함수를 다루는 함수'를 의미합니다. 즉, 다른 함수를 매개변수로 받거나, 함수를 결과로 반환하는 함수를 말합니다. 이 개념은 처음에는 어렵게 느껴질 수 있지만, 코드를 더 유연하고 재사용 가능하게 만드는 강력한 도구입니다.

### 함수를 인자로 받는 예시

가장 흔한 고차 함수의 예시는 다른 함수를 인자로 받아서 실행하는 경우입니다. 마치 여러분이 친구에게 '이 일을 대신 해줘'라고 부탁하는 것과 같습니다.

```javascript
// 이 함수는 'task'라는 다른 함수를 인자로 받아서 'times'만큼 반복 실행합니다.
function repeat(task, times) {
  for (let i = 0; i < times; i++) {
    task(); // 인자로 받은 task 함수를 실행합니다.
  }
}

// 'Hello'을 출력하는 함수를 정의합니다.
const sayMeow = () => console.log('Hello 🐱');

// repeat 함수에 sayMeow 함수와 3이라는 숫자를 인자로 전달합니다.
repeat(sayMeow, 3);
// 출력:
// Hello 🐱
// Hello 🐱
// Hello 🐱

// 함수를 직접 인자로 전달할 수도 있습니다.
repeat(() => console.log('World 🐶'), 2);
// 출력:
// World 🐶
// World 🐶
```

### 함수를 반환하는 예시

고차 함수는 함수를 만들어서 반환할 수도 있습니다. 즉 어떤 함수를 호출하면 또 다른 함수를 만들어서 반환해주는 경우입니다.

```javascript
// 이 함수는 'factor'라는 값을 받아서, 새로운 함수를 만들어 반환합니다.
function createMultiplier(factor) {
  // 반환되는 함수는 'number'를 받아서 'factor'와 곱한 값을 반환합니다.
  return (number) => number * factor;
}

const double = createMultiplier(2);  // createMultiplier 함수를 호출하여 factor가 2인 새로운 함수를 만듭니다.
                                   // double은 이제 '어떤 숫자를 받으면 2를 곱해주는 함수'가 됩니다.
console.log(double(5));             // double 함수를 호출하여 5에 2를 곱합니다. 출력: 10

const triple = createMultiplier(3); // createMultiplier 함수를 호출하여 factor가 3인 새로운 함수를 만듭니다.
console.log(triple(7));             // triple 함수를 호출하여 7에 3을 곱합니다. 출력: 21
```

> [!TIP]
> 고차 함수는 코드를 더 유연하고 모듈화하여 작성할 수 있게 도와줍니다. 복잡한 로직을 작은 함수들로 나누고, 이 함수들을 조합하여 새로운 기능을 만들 때 유용하게 사용됩니다. 처음에는 어렵게 느껴질 수 있지만, JavaScript의 강력한 기능 중 하나이므로 꾸준히 연습하면 익숙해질 것입니다.

---

- [목차로 돌아가기](../README.md)
- [이전 강의로 이동](04-ES6-Conditional-Statements-and-Loops.md)
- [다음 강의로 이동](06-ES6-Arrays-and-Objects.md)
