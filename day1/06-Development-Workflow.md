# 06. 개발 워크플로우

이 문서는 소프트웨어 개발의 전체적인 흐름과 그 안에서 프론트엔드 개발자가 어떤 역할을 하는지, 그리고 효과적인 협업을 위해 무엇이 필요한지를 상세히 설명합니다.

## 목차

1. [소프트웨어 개발 생명주기 (SDLC) 와 방법론](#1-소프트웨어-개발-생명주기-sdlc-와-방법론)
   - [1-1) SDLC의 기본 단계](#1-1-sdlc의-기본-단계)
   - [1-2) 주요 개발 방법론](#1-2-주요-개발-방법론)
2. [프론트엔드 개발자의 일반적인 개발 워크플로우 (애자일 환경 중심)](#2-프론트엔드-개발자의-일반적인-개발-워크플로우-애자일-환경-중심)
3. [성공적인 협업을 위해 필요한 것들](#3-성공적인-협업을-위해-필요한-것들)
4. [Git & GitHub 실무 협업 심화: 문제 상황과 해결책](#4-git--github-실무-협업-심화-문제-상황과-해결책)
   - [4-1) 흔한 실수와 어려움 (그리고 해결책)](#4-1-흔한-실수와-어려움-그리고-해결책)
   - [4-2) 더 효율적인 협업을 위한 브랜치 전략](#4-2-더-효율적인-협업을-위한-브랜치-전략)
   - [4-3) Pull Request와 코드 리뷰 문화](#4-3-pull-request와-코드-리뷰-문화)

---

## 1) 소프트웨어 개발 생명주기 (SDLC) 와 방법론

소프트웨어 개발 생명주기(Software Development Life Cycle, SDLC)는 고품질의 소프트웨어를 가장 효율적인 방법으로 개발하고 유지보수하기 위해 정의된 일련의 과정입니다. 이 과정을 어떤 철학과 규칙으로 운영하는지에 따라 여러 **개발 방법론**으로 나뉩니다.

### 1-1) SDLC의 기본 단계

1.  **요구사항 분석**: 만들고자 하는 소프트웨어의 목표, 기능, 제약 조건을 정의합니다.
2.  **설계**: 요구사항을 바탕으로 시스템의 구조(아키텍처), UI/UX 등을 구체적으로 설계합니다.
3.  **구현**: 설계된 내용을 바탕으로 실제 코드를 작성하여 소프트웨어를 개발합니다.
4.  **테스트**: 구현된 소프트웨어가 요구사항에 맞게 동작하는지, 버그는 없는지 검증합니다.
5.  **배포**: 테스트가 완료된 소프트웨어를 사용자가 접근할 수 있는 실제 운영 환경에 출시합니다.
6.  **유지보수**: 배포된 소프트웨어의 문제를 해결하고, 새로운 기능을 추가하거나 성능을 개선합니다.

### 1-2) 주요 개발 방법론

#### 폭포수 모델 (Waterfall Model)
-   **개념**: 각 단계를 순차적으로, 한 단계가 완전히 끝나야 다음 단계로 넘어가는 전통적인 방법론입니다.
-   **장점**: 계획이 명확하고, 전체 과정을 이해하기 쉽습니다.
-   **단점**: 변화에 유연하게 대처하기 힘들어, 초기 요구사항이 잘못되면 프로젝트 전체에 큰 영향을 미칩니다.

#### 애자일 방법론 (Agile Methodology)
-   **개념**: 변화에 유연하게 대응하기 위해, 짧은 주기의 개발 단위를 반복하여 프로젝트를 진행하는 현대적인 방법론입니다. **"일단 시도하고, 피드백을 통해 개선해나가는"** 방식을 선호합니다.
-   **핵심 가치**: **개인과 상호작용**, **동작하는 소프트웨어**, **고객과의 협력**, **변화에 대한 대응**을 중시합니다.
-   **종류**: 애자일 철학을 구현하는 여러 프레임워크가 있으며, **스크럼(Scrum)**과 **칸반(Kanban)**이 가장 대표적입니다.

---

## 2) 프론트엔드 개발자의 일반적인 개발 워크플로우 (애자일 환경 중심)

현대의 프론트엔드 개발자는 애자일 환경 속에서 다음과 같은 구체적인 작업 흐름을 따르는 경우가 많습니다.

1.  **요구사항 확인 및 설계 이해**: 기획, 디자인 결과물을 바탕으로 만들 기능의 목표와 맥락을 이해합니다.
2.  **개발 환경 설정**: `npm install`, `git branch` 등 개발에 필요한 환경을 준비합니다.
3.  **UI 구현 (마크업 & 스타일링)**: HTML, CSS로 시각적인 구조와 디자인을 구현합니다.
4.  **기능 및 로직 구현**: JavaScript로 사용자의 상호작용과 데이터 흐름을 제어합니다.
5.  **테스트 및 디버깅**: 다양한 종류의 테스트를 통해 코드의 안정성과 품질을 보장합니다.
6.  **코드 리뷰 및 병합**: Pull Request를 통해 동료의 피드백을 받고, 코드를 개선하여 메인 브랜치에 통합합니다.
7.  **배포**: CI/CD 파이프라인을 통해 사용자에게 새로운 버전을 출시합니다.

---

## 3) 성공적인 협업을 위해 필요한 것들

-   **역할군과의 소통**: 기획자, 디자이너, 백엔드 개발자, QA 엔지니어 등 다양한 역할군과 긴밀하게 소통하며 공동의 목표를 향해 나아갑니다.
-   **협업 도구**: Git, Slack, Jira, Figma, Notion 등 목적에 맞는 도구를 활용하여 효율적으로 정보를 공유하고 작업을 관리합니다.
-   **규칙과 약속**: 코딩 컨벤션, 커밋 메시지 규칙 등 팀의 생산성을 높이는 약속을 정하고 지킵니다.

---

## 4) Git & GitHub 실무 협업 심화: 문제 상황과 해결책

이론을 배우는 것과 실제 팀 프로젝트에서 Git을 사용하는 것은 다를 수 있습니다. 여기서는 협업 시 자주 발생하는 문제 상황과 이를 해결하고, 더 나아가 효율적인 협업을 이끌어내는 실무적인 팁을 소개합니다.

### 4-1) 흔한 실수와 어려움 (그리고 해결책)

#### **상황 1: 잦은 충돌(Conflict) 발생과 어려운 해결**
-   **문제점**: 여러 명이 같은 파일을 수정하거나, 내 로컬 브랜치가 원격 브랜치의 최신 상태를 반영하지 않은 채 작업하면 병합(Merge) 시 충돌이 발생합니다.
-   **해결 및 예방**:
    -   **작업 전 항상 `pull` 하기**: `git switch main` → `git pull origin main` → `git switch -c feature/새기능` 순서로 항상 최신 코드에서 작업을 시작하는 습관을 들입니다.
    -   **작업 단위 잘게 쪼개기**: 큰 기능을 작은 단위로 나누어 Pull Request(PR)를 요청하면 충돌 가능성이 줄고 리뷰도 쉬워집니다.
    -   **소통하기**: 팀원과 현재 어떤 부분을 작업하고 있는지 공유하여 같은 파일 수정을 미연에 방지합니다.

#### **상황 2: 의미 없는 커밋 메시지와 지저분한 히스토리**
-   **문제점**: `git commit -m "수정"` 과 같은 메시지는 나중에 히스토리를 추적할 때 아무런 도움이 되지 않습니다.
-   **해결 및 예방**:
    -   **커밋 메시지 컨벤션 도입**: `feat:`, `fix:`, `docs:` 와 같은 접두사를 사용하여 커밋의 의도를 명확히 밝힙니다.
    -   **하나의 커밋에는 하나의 논리적 변경만**: 관련된 코드 변경 사항들을 하나의 커밋으로 묶습니다.

#### **상황 3: 너무 거대한 Pull Request (PR)**
-   **문제점**: 수천 줄의 코드가 변경된 거대한 PR은 리뷰어가 내용을 파악하기 어렵고, 잠재적인 버그를 놓치기 쉽습니다.
-   **해결 및 예방**:
    -   **PR은 작고 집중적으로**: "하나의 PR은 하나의 문제를 해결해야 한다"는 원칙을 지킵니다.
    -   **WIP (Work In Progress) PR 활용**: 개발 중인 기능에 대해 미리 PR을 올려 팀원의 중간 피드백을 구합니다.

### 4-2) 더 효율적인 협업을 위한 브랜치 전략

팀에서 브랜치를 어떻게 나누고 운영할지 규칙을 정하는 것을 **브랜치 전략**이라고 합니다. 어떤 전략을 선택하느냐에 따라 팀의 개발 문화와 생산성이 크게 달라질 수 있습니다.

#### 1. Git Flow
-   **개념**: 가장 잘 알려진 전략 중 하나로, 브랜치를 역할에 따라 `main`, `develop`, `feature`, `release`, `hotfix` 5가지로 엄격하게 나눕니다.
-   **주요 브랜치**:
    -   `main`: 실제 배포되는 가장 안정적인 버전의 코드.
    -   `develop`: 다음 버전을 위해 개발 중인 코드를 모으는 브랜치.
    -   `feature/*`: 새로운 기능 개발을 위한 브랜치. `develop`에서 생성하여 `develop`으로 병합합니다.
    -   `release/*`: 배포를 준비하기 위한 브랜치. `develop`에서 생성하여 `main`과 `develop`에 병합합니다.
    -   `hotfix/*`: 배포된 버전의 긴급한 버그를 수정하는 브랜치. `main`에서 생성하여 `main`과 `develop`에 병합합니다.
-   **장점**: 역할이 명확히 분리되어 있어 안정적이고 체계적인 관리가 가능합니다.
-   **단점**: 복잡하고 번거로워, 빠른 주기의 웹 개발이나 CI/CD 환경에는 적합하지 않을 수 있습니다.

#### 2. GitHub Flow
-   **개념**: Git Flow를 단순화한 모델로, `main` 브랜치와 `feature` 브랜치 두 종류만 사용합니다.
-   **워크플로우**:
    1.  `main` 브랜치는 항상 배포 가능한 상태로 유지됩니다.
    2.  새로운 작업(기능, 버그 수정 등)은 `main`에서 새로 만든 브랜치에서 진행합니다.
    3.  작업이 끝나면 `main`을 대상으로 Pull Request를 생성합니다.
    4.  리뷰와 테스트를 통과하면 `main`에 병합하고, 즉시 배포합니다.
-   **장점**: 매우 단순하고 직관적입니다. CI/CD와 잘 맞아떨어져 현대 웹 애플리케이션 개발에 널리 쓰입니다.
-   **단점**: 여러 버전을 동시에 관리해야 하거나, 명확한 릴리즈 계획이 중요한 프로젝트에는 부적합할 수 있습니다.

#### 3. GitLab Flow
-   **개념**: GitHub Flow의 장점을 취하면서, 배포 환경에 따라 브랜치를 추가하여 안정성을 보강한 전략입니다.
-   **워크플로우**: `main` 브랜치 외에 `staging`, `production`과 같은 **환경 브랜치**를 둡니다. `feature` 브랜치가 `main`에 병합되면, 먼저 `staging` 환경에 배포하여 테스트를 거칩니다. 여기서 안정성이 검증되면 `production` 브랜치로 병합하여 최종 사용자에게 배포합니다.
-   **장점**: 단순함을 유지하면서도, 여러 단계의 검증을 통해 배포 안정성을 높일 수 있습니다.
-   **단점**: Git Flow보다는 단순하지만, GitHub Flow보다는 약간의 복잡성이 추가됩니다.

#### 4. 트렁크 기반 개발 (Trunk-Based Development)
-   **개념**: 모든 개발자가 `main`이라는 단일 브랜치(Trunk, 줄기)에 직접 코드를 커밋하는 방식입니다.
-   **워크플로우**: 개발자들은 작은 단위의 변경사항을 매우 짧은 주기로 `main`에 커밋하고 통합합니다. 미완성된 기능은 **기능 플래그(Feature Flag)**를 사용하여 사용자에게 노출되지 않도록 숨깁니다.
-   **장점**: 브랜치를 관리하는 비용이 없고, 지속적인 통합(CI)이 극대화되어 코드 충돌이 거의 발생하지 않습니다.
-   **단점**: 매우 높은 수준의 테스트 자동화와 팀원들의 숙련도가 필요합니다. `main` 브랜치가 깨지면 모든 팀원에게 영향을 미칩니다.

> [!TIP]
> **어떤 전략을 선택해야 할까?**
> 정답은 없습니다. 팀의 규모, 프로젝트의 성격, 배포 주기, 팀원의 숙련도 등을 종합적으로 고려하여 우리 팀에 가장 잘 맞는 전략을 선택하고 발전시켜 나가는 것이 중요합니다.

### 4-3) Pull Request와 코드 리뷰 문화

-   **PR 템플릿 활용**: PR 생성 시 작업 내용, 변경 사항, 관련 이슈, 스크린샷 등을 포함하는 템플릿을 만들어두면 리뷰의 효율성이 올라갑니다.
-   **건강한 코드 리뷰 문화**: 리뷰는 코드를 비난하는 시간이 아니라, 함께 더 나은 코드를 만들어가는 과정입니다. 질문하고, 제안하고, 칭찬하며 긍정적인 분위기 속에서 지식을 공유하는 것이 중요합니다.

> [!WARNING]
> **`main` 브랜치에 강제로 푸시(`force push`)하지 마세요!**
> `git push --force` 명령어는 원격 저장소의 히스토리를 강제로 덮어쓰기 때문에, 다른 팀원들의 작업 내역과 충돌하여 저장소를 망가뜨릴 수 있습니다. 개인 브랜치에서 히스토리를 정리하는 등 매우 제한적인 상황에서만 신중하게 사용해야 합니다.

---

- [목차로 돌아가기](../README.md)
- [이전 강의로 이동](05-GitHub.md)
- [다음 강의로 이동](07-Deployment.md)
