# 02. 클라이언트-서버 구조

이 자료는 웹 개발에 대해 아무런 지식이 없는 사람도 클라이언트-서버 구조의 기본 원리를 이해할 수 있도록 돕기 위한 기초 안내서입니다. 클라이언트와 서버가 무엇인지, 어떻게 서로 소통하는지, 그리고 이 구조가 왜 중요한지에 대해 단계적으로 설명합니다.

## 1. 클라이언트-서버 구조란?

클라이언트-서버 구조는 컴퓨터 네트워크에서 가장 기본적이고 중요한 개념 중 하나입니다. 이는 두 개의 서로 다른 역할을 하는 컴퓨터나 프로그램이 네트워크를 통해 서로 소통하는 방식을 말합니다.

### 간단한 비유로 이해하기

클라이언트-서버 구조를 이해하기 위해 일상생활의 예를 들어보겠습니다:

**식당에서 음식 주문하기**
- **고객(클라이언트)**: 메뉴를 보고 음식을 주문하는 사람
- **식당(서버)**: 주문을 받아서 음식을 만들어 제공하는 곳
- **주문 과정**: 고객이 "불고기 정식 하나 주세요"라고 요청하면, 식당에서 불고기 정식을 만들어서 고객에게 제공

웹에서도 이와 똑같은 방식으로 동작합니다:
- **브라우저(클라이언트)**: 웹페이지를 요청하는 프로그램
- **웹서버(서버)**: 요청받은 웹페이지를 만들어서 제공하는 컴퓨터
- **요청 과정**: 브라우저가 "네이버 메인페이지를 보여주세요"라고 요청하면, 서버에서 네이버 메인페이지를 만들어서 브라우저에게 전송

### 클라이언트-서버 구조의 핵심 특징

1. **역할 분담**: 클라이언트는 요청하고, 서버는 응답합니다
2. **일대다 관계**: 하나의 서버가 여러 클라이언트의 요청을 동시에 처리할 수 있습니다
3. **네트워크 통신**: 클라이언트와 서버는 인터넷을 통해 데이터를 주고받습니다

---

## 2. 클라이언트(Client)란?

클라이언트는 서비스를 요청하는 쪽을 말합니다. 웹에서 클라이언트는 주로 **웹 브라우저**를 의미합니다.

### 웹 브라우저의 역할

웹 브라우저는 우리가 일상적으로 사용하는 프로그램입니다:

- **Chrome**: 구글에서 만든 브라우저
- **Safari**: 애플에서 만든 브라우저 (Mac, iPhone에서 기본 브라우저)
- **Firefox**: 모질라에서 만든 브라우저
- **Edge**: 마이크로소프트에서 만든 브라우저

### 클라이언트가 하는 일

1. **사용자 입력 받기**: 주소창에 URL을 입력하거나 링크를 클릭
2. **서버에 요청 보내기**: "이 웹페이지를 보여주세요"라고 요청
3. **응답 받기**: 서버로부터 HTML, CSS, JavaScript 파일을 받음
4. **화면에 표시하기**: 받은 파일들을 해석해서 우리가 볼 수 있는 웹페이지로 변환

### 클라이언트의 종류

웹 브라우저 외에도 다양한 클라이언트가 있습니다:

- **모바일 앱**: 카카오톡, 인스타그램 앱 등
- **데스크톱 프로그램**: 카카오톡 PC버전, 디스코드 등
- **API 클라이언트**: 다른 서버에서 데이터를 요청하는 프로그램

---

## 3. 서버(Server)란?

서버는 클라이언트의 요청을 받아서 적절한 응답을 제공하는 컴퓨터나 프로그램을 말합니다.

### 서버의 기본 개념

**서버**라는 단어는 "서비스를 제공한다(serve)"는 뜻에서 나왔습니다. 즉, 서버는 다른 컴퓨터나 프로그램에게 서비스를 제공하는 역할을 합니다.

### 서버가 하는 일

1. **요청 대기**: 클라이언트로부터 요청이 올 때까지 기다림
2. **요청 처리**: 받은 요청을 분석하고 적절한 작업을 수행
3. **응답 생성**: 요청에 맞는 데이터나 파일을 준비
4. **응답 전송**: 준비된 데이터를 클라이언트에게 전송

### 서버의 종류

#### 1. 웹 서버 (Web Server)
- **역할**: HTML, CSS, JavaScript, 이미지 등의 파일을 제공
- **예시**: Apache, Nginx
- **비유**: 도서관의 사서가 책을 찾아서 빌려주는 것과 비슷

#### 2. 애플리케이션 서버 (Application Server)
- **역할**: 복잡한 로직을 처리하고 동적인 내용을 생성
- **예시**: Node.js, Java Spring, Python Django
- **비유**: 요리사가 주문에 맞춰 음식을 만드는 것과 비슷

#### 3. 데이터베이스 서버 (Database Server)
- **역할**: 데이터를 저장하고 관리
- **예시**: MySQL, PostgreSQL, MongoDB
- **비유**: 창고 관리자가 물건을 정리하고 찾아주는 것과 비슷

#### 4. 파일 서버 (File Server)
- **역할**: 파일을 저장하고 공유
- **예시**: Google Drive, Dropbox의 서버
- **비유**: 사물함이나 보관함 역할

---

## 4. 클라이언트-서버 통신 과정

클라이언트와 서버가 어떻게 소통하는지 단계별로 자세히 알아보겠습니다.

### 기본 통신 흐름

```
1. 사용자 행동 → 2. 클라이언트 요청 → 3. 서버 처리 → 4. 서버 응답 → 5. 클라이언트 표시
```

### 실제 예시: 네이버 메인페이지 접속하기

#### 1단계: 사용자가 주소 입력
```
사용자가 브라우저 주소창에 "www.naver.com" 입력
```

#### 2단계: DNS 조회
```
브라우저: "www.naver.com의 IP 주소가 뭐야?"
DNS 서버: "223.130.195.200이야"
```

#### 3단계: 서버에 요청 전송
```
브라우저 → 네이버 서버: "메인페이지를 보여줘"
```

#### 4단계: 서버에서 응답 생성
```
네이버 서버에서 처리:
- 메인페이지 HTML 파일 준비
- CSS 스타일 파일 준비
- JavaScript 파일 준비
- 최신 뉴스 데이터 가져오기
- 날씨 정보 가져오기
```

#### 5단계: 클라이언트에 응답 전송
```
네이버 서버 → 브라우저: HTML + CSS + JavaScript + 데이터
```

#### 6단계: 브라우저에서 화면 표시
```
브라우저가 받은 파일들을 해석해서 네이버 메인페이지를 화면에 표시
```

### 통신에 사용되는 프로토콜

#### HTTP (HyperText Transfer Protocol)
- **역할**: 웹에서 데이터를 주고받는 규칙
- **특징**: 요청과 응답의 형식을 정의

#### HTTPS (HTTP Secure)
- **역할**: HTTP에 보안 기능을 추가한 버전
- **특징**: 데이터를 암호화해서 전송

---

## 5. 요청(Request)과 응답(Response)

클라이언트-서버 통신의 핵심은 **요청**과 **응답**입니다.

### 요청(Request)의 구성 요소

#### 1. HTTP 메서드
요청의 목적을 나타내는 동사입니다:

- **GET**: "데이터를 가져와 줘"
  - 예: 웹페이지 보기, 검색 결과 가져오기
- **POST**: "새로운 데이터를 저장해 줘"
  - 예: 회원가입, 게시글 작성
- **PUT**: "기존 데이터를 수정해 줘"
  - 예: 프로필 정보 수정
- **DELETE**: "데이터를 삭제해 줘"
  - 예: 게시글 삭제, 회원 탈퇴

#### 2. URL (Uniform Resource Locator)
요청하고자 하는 자원의 위치를 나타냅니다:

```
https://www.example.com/users/123/profile
```

- `https://`: 프로토콜 (통신 방식)
- `www.example.com`: 서버 주소
- `/users/123/profile`: 자원의 경로

#### 3. 헤더(Header)
요청에 대한 추가 정보를 담습니다:

```
Content-Type: application/json
Authorization: Bearer abc123token
User-Agent: Chrome/91.0.4472.124
```

- **Content-Type**: 보내는 데이터의 형식
- **Authorization**: 인증 정보
- **User-Agent**: 클라이언트 정보 (어떤 브라우저인지)

#### 4. 본문(Body)
실제 전송할 데이터를 담습니다 (주로 POST, PUT에서 사용):

```json
{
  "name": "홍길동",
  "email": "hong@example.com",
  "age": 25
}
```

### 응답(Response)의 구성 요소

#### 1. 상태 코드(Status Code)
요청 처리 결과를 나타내는 숫자입니다:

- **200 OK**: 성공적으로 처리됨
- **404 Not Found**: 요청한 자원을 찾을 수 없음
- **500 Internal Server Error**: 서버에서 오류 발생

#### 2. 헤더(Header)
응답에 대한 추가 정보를 담습니다:

```
Content-Type: text/html
Set-Cookie: sessionId=abc123
Cache-Control: max-age=3600
```

#### 3. 본문(Body)
실제 응답 데이터를 담습니다:

```html
<!DOCTYPE html>
<html>
<head>
    <title>안녕하세요</title>
</head>
<body>
    <h1>환영합니다!</h1>
</body>
</html>
```

---

## 6. 클라이언트-서버 구조의 장점

### 1. 역할 분담
- **클라이언트**: 사용자 인터페이스에 집중
- **서버**: 데이터 처리와 비즈니스 로직에 집중
- **결과**: 각각의 전문성을 높일 수 있음

### 2. 확장성
- 서버 하나가 수많은 클라이언트를 동시에 처리 가능
- 사용자가 늘어나면 서버를 추가하거나 성능을 향상시킬 수 있음

### 3. 유지보수성
- 클라이언트와 서버를 독립적으로 개발하고 수정할 수 있음
- 서버의 로직이 바뀌어도 클라이언트는 영향을 받지 않음

### 4. 보안성
- 중요한 데이터와 로직을 서버에 두어 보안을 강화
- 클라이언트는 필요한 정보만 받아서 사용

### 5. 일관성
- 모든 클라이언트가 같은 서버에서 동일한 데이터를 받음
- 데이터의 일관성을 유지하기 쉬움

---

## 7. 클라이언트-서버 구조의 단점

### 1. 네트워크 의존성
- 인터넷 연결이 없으면 서비스를 사용할 수 없음
- 네트워크 속도가 느리면 응답이 지연됨

### 2. 서버 장애 시 영향
- 서버에 문제가 생기면 모든 클라이언트가 영향을 받음
- 단일 장애점(Single Point of Failure) 문제

### 3. 확장성의 한계
- 사용자가 급격히 늘어나면 서버에 부하가 집중
- 서버 용량을 초과하면 서비스가 중단될 수 있음

### 4. 개발 복잡성
- 클라이언트와 서버를 모두 개발해야 함
- 통신 프로토콜과 데이터 형식을 정의해야 함

---

## 8. 다양한 클라이언트-서버 구조

### 1. 2-Tier 구조 (클라이언트-서버)
```
클라이언트 ←→ 서버
```
- **특징**: 클라이언트가 직접 데이터베이스 서버에 접근
- **예시**: 간단한 데스크톱 애플리케이션
- **장점**: 구조가 단순함
- **단점**: 확장성이 제한적

### 2. 3-Tier 구조 (클라이언트-애플리케이션서버-데이터베이스)
```
클라이언트 ←→ 애플리케이션 서버 ←→ 데이터베이스 서버
```
- **특징**: 애플리케이션 서버가 비즈니스 로직을 처리
- **예시**: 대부분의 웹 애플리케이션
- **장점**: 역할 분담이 명확, 확장성이 좋음
- **단점**: 구조가 복잡함

### 3. N-Tier 구조 (다층 구조)
```
클라이언트 ←→ 웹서버 ←→ 애플리케이션서버 ←→ 데이터베이스서버
                ↓
            캐시서버, 파일서버 등
```
- **특징**: 여러 개의 서버가 각각의 역할을 담당
- **예시**: 대규모 웹 서비스 (페이스북, 구글 등)
- **장점**: 성능과 확장성이 뛰어남
- **단점**: 구조가 매우 복잡함

---

## 9. 실제 웹 서비스에서의 클라이언트-서버 구조

### 소셜 미디어 서비스 예시 (인스타그램)

#### 클라이언트 측
- **웹 브라우저**: 인스타그램 웹사이트
- **모바일 앱**: 인스타그램 iOS/Android 앱
- **기능**: 사진 업로드, 피드 보기, 좋아요, 댓글 등

#### 서버 측
- **웹 서버**: 정적 파일 (이미지, CSS, JavaScript) 제공
- **애플리케이션 서버**: 사용자 인증, 피드 생성, 알림 처리
- **데이터베이스 서버**: 사용자 정보, 게시물, 댓글 저장
- **파일 서버**: 업로드된 사진과 동영상 저장

#### 통신 과정
1. 사용자가 앱에서 사진을 업로드
2. 앱이 서버에 사진 파일과 메타데이터 전송
3. 서버가 사진을 파일 서버에 저장
4. 서버가 게시물 정보를 데이터베이스에 저장
5. 서버가 팔로워들에게 알림 전송
6. 다른 사용자들의 피드에 새 게시물 표시

### 온라인 쇼핑몰 예시 (쇼핑몰 사이트)

#### 클라이언트 측
- **웹 브라우저**: 쇼핑몰 웹사이트
- **모바일 앱**: 쇼핑몰 앱
- **기능**: 상품 검색, 장바구니, 결제, 주문 조회

#### 서버 측
- **웹 서버**: 상품 이미지, 웹페이지 파일 제공
- **애플리케이션 서버**: 상품 검색, 결제 처리, 주문 관리
- **데이터베이스 서버**: 상품 정보, 사용자 정보, 주문 내역
- **결제 서버**: 신용카드, 계좌이체 등 결제 처리

#### 통신 과정
1. 사용자가 "노트북" 검색
2. 앱이 서버에 검색 요청 전송
3. 서버가 데이터베이스에서 노트북 관련 상품 검색
4. 서버가 검색 결과를 앱에 전송
5. 앱이 상품 목록을 화면에 표시
6. 사용자가 상품을 선택하고 구매 버튼 클릭
7. 앱이 주문 정보를 서버에 전송
8. 서버가 결제를 처리하고 주문을 데이터베이스에 저장

---

## 10. 클라이언트-서버 구조와 프론트엔드 개발

### 프론트엔드 개발자의 역할

프론트엔드 개발자는 주로 **클라이언트 쪽**을 개발합니다:

#### 1. 사용자 인터페이스(UI) 개발
- HTML로 웹페이지 구조 만들기
- CSS로 디자인과 레이아웃 꾸미기
- JavaScript로 상호작용 기능 구현

#### 2. 서버와의 통신 구현
- API 호출을 통해 서버에서 데이터 가져오기
- 사용자 입력을 서버로 전송하기
- 서버 응답을 받아서 화면에 표시하기

#### 3. 사용자 경험(UX) 개선
- 로딩 중일 때 스피너 표시
- 오류 발생 시 적절한 메시지 표시
- 반응형 디자인으로 다양한 기기에서 잘 보이게 하기

### 백엔드 개발자와의 협업

프론트엔드 개발자는 백엔드 개발자와 긴밀하게 협업해야 합니다:

#### 1. API 설계
- 어떤 데이터를 주고받을지 정하기
- 요청과 응답의 형식 정의하기
- 오류 처리 방법 정하기

#### 2. 데이터 형식 통일
- JSON 형태로 데이터 주고받기
- 날짜, 숫자 등의 형식 맞추기
- 다국어 지원 방식 정하기

#### 3. 보안 고려사항
- 사용자 인증 방식 정하기
- 민감한 정보 처리 방법 정하기
- HTTPS 사용 등 보안 프로토콜 적용

---

## 11. 최신 트렌드와 발전 방향

### 1. 마이크로서비스 아키텍처
- **개념**: 하나의 큰 서버를 여러 개의 작은 서비스로 분리
- **장점**: 각 서비스를 독립적으로 개발하고 배포할 수 있음
- **예시**: 넷플릭스, 아마존 등에서 사용

### 2. 서버리스 아키텍처
- **개념**: 서버 관리 없이 코드만 실행하는 방식
- **장점**: 서버 운영 부담이 줄어듦, 사용한 만큼만 비용 지불
- **예시**: AWS Lambda, Vercel Functions

### 3. 엣지 컴퓨팅
- **개념**: 사용자와 가까운 곳에 서버를 두어 응답 속도 향상
- **장점**: 빠른 응답 시간, 네트워크 부하 분산
- **예시**: CDN (Content Delivery Network)

### 4. 실시간 통신
- **개념**: 클라이언트와 서버가 실시간으로 데이터를 주고받음
- **기술**: WebSocket, Server-Sent Events
- **예시**: 채팅 앱, 실시간 게임, 주식 거래 앱

---

## 12. 클라이언트-서버 구조 실습 준비

### 개발 환경 이해하기

실제 웹 개발을 할 때는 다음과 같은 환경을 구성합니다:

#### 개발 환경 (Development)
- **클라이언트**: 로컬 컴퓨터에서 실행 (예: localhost:3000)
- **서버**: 로컬 컴퓨터나 개발용 서버에서 실행
- **목적**: 기능 개발과 테스트

#### 스테이징 환경 (Staging)
- **클라이언트**: 실제 서비스와 비슷한 환경에서 실행
- **서버**: 실제 서비스와 비슷한 서버에서 실행
- **목적**: 배포 전 최종 테스트

#### 프로덕션 환경 (Production)
- **클라이언트**: 실제 사용자들이 접근하는 환경
- **서버**: 실제 서비스를 제공하는 서버
- **목적**: 실제 서비스 운영

### 학습 로드맵

클라이언트-서버 구조를 제대로 이해하기 위한 학습 순서:

1. **HTML/CSS/JavaScript 기초** (클라이언트 개발)
2. **HTTP 프로토콜 이해** (통신 방식)
3. **API 사용법 학습** (서버와의 통신)
4. **백엔드 기초 이해** (서버 개발 기초)
5. **실제 프로젝트 만들기** (전체 구조 경험)

---

## 13. 정리 및 다음 단계

### 핵심 내용 정리

1. **클라이언트-서버 구조**는 웹의 기본 동작 방식입니다
2. **클라이언트**는 요청하는 쪽, **서버**는 응답하는 쪽입니다
3. **HTTP/HTTPS**를 통해 요청과 응답을 주고받습니다
4. **프론트엔드 개발자**는 주로 클라이언트 쪽을 담당합니다
5. **백엔드 개발자**와의 협업이 중요합니다

### 실생활에서 관찰해보기

이제 웹사이트나 앱을 사용할 때 다음과 같은 관점에서 관찰해보세요:

- 언제 서버에 요청을 보내는지 (로딩 표시가 나타날 때)
- 어떤 데이터를 주고받는지 (검색 결과, 사용자 정보 등)
- 오류가 발생했을 때 어떻게 처리되는지
- 실시간으로 업데이트되는 내용은 무엇인지
