# 8. React 개발자 도구 심화

이전 시간에 우리는 `React.memo`와 `useCallback`을 사용하여 렌더링 성능을 최적화하는 방법을 배웠습니다. 하지만 "언제, 어떤 컴포넌트를 최적화해야 할까?" 라는 질문에 답하려면, 먼저 애플리케이션의 어느 부분에서 성능 저하가 발생하는지 정확히 측정해야 합니다.

이때 사용하는 것이 바로 **React 개발자 도구의 Profiler**입니다. 이번 시간에는 Profiler를 사용하여 애플리케이션의 렌더링 성능을 분석하고 병목 지점을 찾는 방법을 심도 있게 다뤄보겠습니다.

---

## 1) Profiler란 무엇인가?

**Profiler**는 React 애플리케이션의 **렌더링 성능을 측정하고 분석**하기 위한 도구입니다. Profiler를 사용하면 다음과 같은 정보를 얻을 수 있습니다.

-   어떤 컴포넌트가 렌더링되었는가?
-   각 컴포넌트를 렌더링하는 데 얼마나 많은 시간이 소요되었는가?
-   특정 컴포넌트는 왜 리렌더링되었는가?

이 정보를 바탕으로 "성급한 최적화"를 피하고, 데이터에 기반하여 정말로 개선이 필요한 부분을 찾아낼 수 있습니다.

> [!NOTE]
> Profiler는 개발 모드(`NODE_ENV="development"`)에서만 사용할 수 있습니다. 프로덕션 빌드에서는 성능에 미치는 영향을 최소화하기 위해 제외됩니다.

---

## 2) Profiler 사용 방법

Profiler를 사용하는 과정은 매우 간단합니다.

1.  브라우저 개발자 도구에서 **Profiler** 탭을 선택합니다.
2.  왼쪽 위에 있는 파란색 **녹화 시작(Start profiling)** 버튼을 클릭합니다.
3.  성능을 측정하고 싶은 상호작용을 애플리케이션에서 수행합니다. (예: 버튼 클릭, 텍스트 입력, 페이지 이동 등)
4.  다시 빨간색 **녹화 중지(Stop profiling)** 버튼을 눌러 기록을 마칩니다.
5.  수집된 성능 데이터를 분석합니다.

## 3) Profiler 결과 분석하기

녹화를 마치면 여러 가지 그래프와 데이터가 표시됩니다. 처음에는 복잡해 보일 수 있지만, 핵심적인 몇 가지만 알면 쉽게 이해할 수 있습니다.

### 3-1) 커밋(Commit) 정보

화면 상단에는 여러 개의 막대 그래프가 표시됩니다. 여기서 각 막대는 React가 DOM을 업데이트한 <strong>커밋(Commit)</strong>을 의미합니다. 막대가 높을수록 해당 커밋에서 렌더링하는 데 시간이 오래 걸렸다는 뜻입니다. 특정 막대를 클릭하면 해당 커밋에 대한 상세 정보를 볼 수 있습니다.

### 3-2) Flamegraph (불꽃 그래프)

**Flamegraph**는 특정 커밋 시점에 어떤 컴포넌트들이 렌더링되었는지를 계층 구조로 보여줍니다.

-   **그래프의 너비**: 컴포넌트의 너비가 넓을수록 해당 컴포넌트와 그 자식들을 렌더링하는 데 시간이 오래 걸렸음을 의미합니다.
-   **그래프의 색상**:
    -   **노란색/주황색**: 렌더링 시간이 긴 컴포넌트
    -   **파란색**: 렌더링 시간이 짧은 컴포넌트
    -   **회색**: 해당 커밋에서 렌더링되지 않은 컴포넌트 (`React.memo` 등으로 최적화된 경우)

이 그래프를 통해 어떤 컴포넌트가 성능 병목의 원인인지 시각적으로 빠르게 파악할 수 있습니다.

### 3-3) Ranked (순위) 차트

**Ranked** 차트는 현재 커밋에서 렌더링된 컴포넌트들을 **가장 오래 걸린 순서**대로 정렬하여 보여줍니다. Flamegraph가 전체 구조를 보여준다면, Ranked 차트는 가장 느린 컴포넌트를 바로 찾아내는 데 유용합니다.

### 3-4) 컴포넌트 상세 정보 (가장 중요!)

Flamegraph나 Ranked 차트에서 특정 컴포넌트를 클릭하면, 오른쪽 패널에 해당 컴포넌트에 대한 매우 유용한 상세 정보가 나타납니다.

-   **Rendered at**: 이 컴포넌트가 현재 커밋을 포함하여 몇 번의 커밋에서 렌더링되었는지 보여줍니다.
-   **Why did this render?**: <strong>"이 컴포넌트가 왜 리렌더링되었는가?"</strong>에 대한 직접적인 원인을 알려줍니다.
    -   `Props changed`: 부모로부터 받은 props가 변경됨. (어떤 prop이 바뀌었는지도 보여줌)
    -   `State changed`: 컴포넌트 자신의 state가 변경됨.
    -   `Parent component rendered`: 부모 컴포넌트가 리렌더링됨. (최적화가 필요한 지점일 수 있음)
    -   `Hook ... changed`: 특정 Hook의 의존성 배열이 변경됨.

이 "Why did this render?" 정보는 불필요한 리렌더링의 원인을 찾는 데 결정적인 단서를 제공합니다.

---

## 4) 실전 예제: 병목 지점 찾고 최적화하기

이전 강의의 예제를 다시 가져와 Profiler로 분석해봅시다.

```jsx
// 최적화되지 않은 CounterApp
function CounterApp() {
  const [count, setCount] = useState(0);

  const increment = () => setCount(count + 1);

  return (
    <div>
      <p>Count: {count}</p>
      {/* Button은 React.memo로 감싸져 있다고 가정 */}
      <MemoizedButton onClick={increment} />
    </div>
  );
}
```

1.  Profiler 녹화를 시작합니다.
2.  `카운트 올리기` 버튼을 여러 번 클릭합니다.
3.  녹화를 중지합니다.

Profiler 결과에서 `MemoizedButton` 컴포넌트를 클릭해보면, **"Why did this render?"** 섹션에 **"Props changed: onClick"** 이라고 표시될 것입니다. `useCallback`을 사용하지 않았기 때문에 `increment` 함수가 매번 새로 생성되어 prop이 변경되었다고 인식한 것입니다.

이 정보를 바탕으로 우리는 `increment` 함수를 `useCallback`으로 감싸야 한다는 구체적인 최적화 방향을 설정할 수 있습니다.

---

## 5) 정리

-   **Profiler**는 React 애플리케이션의 렌더링 성능을 측정하고 병목을 찾는 공식 도구입니다.
-   **Flamegraph**와 **Ranked** 차트를 통해 어떤 컴포넌트가 느린지 시각적으로 파악할 수 있습니다.
-   컴포넌트 상세 정보의 <strong>"Why did this render?"</strong>는 리렌더링의 원인을 정확히 알려주는 핵심 기능입니다.
-   **추측에 의존하지 말고, Profiler로 측정하고, 데이터에 기반하여 최적화하세요.**

React 개발자 도구의 Profiler를 능숙하게 사용하는 것은 React 개발자의 중요한 역량 중 하나입니다.

---

- [목차로 돌아가기](./README.md)
- [이전 강의로 이동](./07-Rendering-Optimization.md)
- [다음 강의로 이동](./09-Intro-to-Testing.md)
